---
title: Analysis of Beer Reviews
summary: >
  Test description
author: 'Tim Trice'
date: '2018-12-31'
slug: rstudio-in-docker
categories:
  - R
  - tidyverse
tags: 
  - analysis
draft: TRUE
output:
  blogdown::html_page:
    toc: true
    fig_align: center
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      error = TRUE)
```

```{r libraries}
library(corrplot)
library(dplyr)
library(ggplot2)
library(Hmisc)
library(purrr)
library(rvest)
library(stringr)
library(xml2)
```

[One-Size-Fits-All Interview Kit](https://www.linkedin.com/pulse/how-hire-test-data-skills-one-size-fits-all-interview-tanya-cashorali/)

### Data Download

Data courtesy of [Beer Advocate](http://www.beeradvocate.com/).

```{r}
#' Path to download csv
data_dir <- "~/Downloads"

local_file <- sprintf("%s/beer_reviews.csv", data_dir)

if (file.exists(local_file)) {
  df <- readr::read_csv(local_file)
  
} else {

  url <- "https://github.com/timtrice/datasets/blob/master/beer_reviews/beer_reviews.tar.gz?raw=true"
  destdir <- tempdir()
  utils::download.file(file.path(url), zip_file <- tempfile())
  utils::untar(zip_file, exdir = destdir)
  df <- readr::read_csv(sprintf("%s/beer_reviews/beer_reviews.csv", destdir))
  
  if (!dir.exists(data_dir)) 
    dir.create(data_dir)
  
  readr::write_csv(df, file.path(local_file))

}
```

### The Variables

```{r}
str(df)
```

#### brewery_id

```{r}
describe(df$brewery_id)
```

  * continuous variable

  * There are no missing `brewer_id` values.
  
  * The mean is higher than 75% of the values so there is a heavy skew along the lower values for some reason. Question: *Why is this? Is this relevant?*

```{r}
ggplot(df, aes(x = brewery_id)) + geom_histogram(bins = 50)
```

#### brewery_name

```{r}
describe(df$brewery_name)
```

  * Categorical variables

My expectation was for the numbers `n`, `missing` and `distinct` to match up with `brewery_id`, but they don't. While the `missing` count is only slightly off (-15), the `distinct` count is way off (-98). 

```{r}
unique(df$brewery_id[is.na(df$brewery_name)])
```

There are only 2 missing unique `brewer_id`.

The discrepancy suggests some brewery's may have multiple names for the same id. 
```{r}
df %>% 
  group_by(brewery_id) %>% 
  summarise(n = length(unique(brewery_name))) %>% 
  filter(n > 1)
```

My instinct is wrong. I'll flip it. 

```{r}
df %>% 
  group_by(brewery_name) %>% 
  summarise(n = length(unique(brewery_id))) %>% 
  filter(n > 1) %>% 
  arrange(brewery_name)
```

Ok, so 60 `brewery_name` have multiple `brewery_id`. There are also spelling discrepancies, e.g., BJ's Restaurant & Brewery, BJ's Restaurant & Brewhouse, BJ's Restaurant And Brewhouse. These discrepancies will need to be cleaned. 

#### review_time

```{r}
describe(df$review_time)
```

```{r}
ggplot(df, aes(x = review_time)) + geom_histogram(bins = 10000)
```

#### review_overall

```{r}
describe(df$review_overall)
```

```{r}
ggplot(df, aes(x = review_overall)) + geom_bar()
```

  * Categorical

#### review_aroma

```{r}
describe(df$review_aroma)
```

```{r}
ggplot(df, aes(x = review_aroma)) + geom_bar()
```

  * Categorical
  
#### review_appearance

```{r}
describe(df$review_appearance)
```

```{r}
ggplot(df, aes(x = review_appearance)) + geom_bar()
```

  * Categorical

#### review_profilename

```{r}
describe(df$review_profilename)
```

  * Categorical

#### beer_style

```{r}
describe(df$beer_style)
```

  * Categorical

#### review_palate

```{r}
describe(df$review_palate)
```

```{r}
ggplot(df, aes(x = review_palate)) + geom_bar()
```

  * Categorical

#### review_taste

```{r}
describe(df$review_taste)
```

```{r}
ggplot(df, aes(x = review_taste)) + geom_bar()
```

  * Categorical
  
#### beer_abv

```{r}
describe(df$beer_abv)
```

```{r}
df %>% 
  filter(!is.na(beer_abv)) %>% 
  ggplot(aes(x = beer_abv)) + 
  geom_freqpoly(bins = 10)
```

  * Continuous

#### beer_name

```{r}
describe(df$beer_name)
```

#### beer_beerid

```{r}
describe(df$beer_beerid)
```

```{r}
ggplot(df, aes(x = beer_beerid)) + geom_histogram(bins = 50)
```

### Data Cleaning

There are four variables I'm most concerned about that will need to be cleaned: `brewery_id`, `brewery_name`, `beer_name` and `beer_beerid`.

Recall again the list of brewery names that had more than one brewery id:

```{r}
df %>% 
  group_by(brewery_name) %>% 
  summarise(n = length(unique(brewery_id))) %>% 
  filter(n > 1) %>% 
  arrange(brewery_name)
```

I established earlier that brewery id's only have one unique brewery name. I'll go through each name on this list and try to iron out the discrepancies. 

#### Brewery Name Data Validation

I'll start first with "Back Street Brewery". I want to list all distinct `brewery_name` values that begin with "Back St" (use the common St abbreviation to capture both St and Street).

```{r}
df %>% 
  filter(grepl("^Back St", brewery_name)) %>% 
  select(starts_with("b")) %>% 
  distinct(brewery_name, .keep_all = TRUE)
```

There is only one Back St. What about distinct `brewery_id` values?

```{r}
df %>% 
  filter(grepl("^Back St", brewery_name)) %>% 
  select(starts_with("b")) %>% 
  distinct(brewery_id, .keep_all = TRUE)
```

Ok, there are a few different `brewery_id` values for this brewery. I'm a bit stuck on how I can validate the legitimacy (or lack thereof) on these values. 

Are there multiple "Back Street Brewery"? Or, is this a crowd-sourcing error (Yelp is bad with this, too). 

Thankfully, the Beer Advocate website happens to have addresses. We can plug `brewery_id` into a URL and scrape the address info. 

Let me go grab the brewery ids.

```{r}
brewery_ids <- df %>% 
  filter(grepl("^Back St", brewery_name)) %>% 
  select(starts_with("brew")) %>% 
  distinct() %>% 
  pull(brewery_id)

brewery_ids
```

Now I'll write a little scraping function that will return the addresses for each of the breweries.

```{r}
get_addresses <- function(brewery_id) {

  url <- glue::glue("https://www.beeradvocate.com/beer/profile/{brewery_id}/")
  
  xml2::read_html(url) %>% 
    rvest::html_nodes(xpath = "//*[(@id = 'info_box')]") %>% 
    rvest::html_text()
}
```

Get the addresses.

```{r}
addresses <- map(brewery_ids, get_addresses) %>% 
  trimws() %>% 
  str_split(pattern = "[:cntrl:]+") %>% 
  # All address info seems to be in the 3rd element so just grab those.
  map(`[`, 3)

addresses
```

I can do a visual analysis and see none of these are a match. In other words, it looks like we're dealing with a franchise. With that said, "Back Street Brewery" should not be corrected.

I'm going to modify `get_addresses()` to take the pattern I'm searching (in the example above, "^Back St") and just return the results. I don't want to keep typing all of that code.

```{r}
#' @title get_addresses
#' @description Given a dataframe (x) and a pattern for brewery_name, will 
#'    return all addresses for breweries that match that pattern.
#' @param x Dataframe object
#' @pattern regex pattern for brewery names to find
get_addresses <- function(x, pattern) {
  x %>% 
  filter(grepl(pattern, brewery_name)) %>% 
  select(starts_with("brew")) %>% 
  distinct() %>% 
  pull(brewery_id) %>% 
  sprintf("https://www.beeradvocate.com/beer/profile/%s/", .) %>% 
  map(read_html) %>% 
  map(html_nodes, xpath = "//*[(@id = 'info_box')]") %>% 
  map(html_text) %>% 
  str_split(pattern = "[:cntrl:]+") %>% 
  map(`[`, 4)
}
```

I'll test it. 

```{r}
get_addresses(df, "^Back St")
```

[[satisfied face meme]]

Ok, now I just need to go through our discrepancies. It would be nice to write a function to do this as well. But the pattern requires human involvement; oh, well.

Of the known items with possible issues, only those that immediately follow had true issues.

##### Bare Bones Grill & Brewery

```{r}
ptn <- "^Bare\\s"
```

```{r}
#' Find all possible matches
df %>% filter(grepl(ptn, brewery_name)) %>% 
  select(starts_with("brew")) %>% 
  distinct(brewery_id, .keep_all = TRUE)
```

```{r}
#' List addresses
get_addresses(df, ptn)
```

In this case, the page for id 1953 no longer exists. So, there is no way to validate the discrepancy. In this case I will update all 1953 `brewery_id` values to 1954.

```{r}
df$brewery_id[df$brewery_id == 1953] <- 1954
```

#### Rocky Coulee Brewing Co.

```{r}
ptn <- "^Rocky\\sC"
```

```{r}
#' Find all possible matches
df %>% filter(grepl(ptn, brewery_name)) %>% 
  select(starts_with("brew")) %>% 
  distinct(brewery_id, .keep_all = TRUE)
```

```{r}
#' List addresses
get_addresses(df, ptn)
```

"Rocky Coulee Brewing Co." has two identical entries in the database. The only difference in the address listings is one digit in the phone number.

I'll update those with `brewery_id` 13094 to 12984.

```{r}
df$brewery_id[df$brewery_id == 13094] <- 12984
```

### Exploratory

```{r}
cc <- df[complete.cases(df),] %>% 
  select(starts_with("review"), -review_time, -review_profilename, beer_abv)
```

```{r}
cor(cc)
```

Most positive relationship seems to be between `review_overall` and `review_taste`. I want to take the mean `review_overall` and `review_taste` per `beer_beerid` and draw a scatterplot.

```{r}
df %>% 
  group_by(beer_beerid) %>% 
  summarise(mean_review_overall = mean(review_overall, na.rm = TRUE), 
            mean_review_taste = mean(review_taste, na.rm = TRUE)) %>% 
  ggplot(aes(x = mean_review_overall, y = mean_review_taste)) + 
  geom_point() + 
  geom_smooth()
```

Is this really surprising?

Next to taste is `review_palate`; let's check that out.

```{r}
df %>% 
  group_by(beer_beerid) %>% 
  summarise(mean_review_overall = mean(review_overall, na.rm = TRUE), 
            mean_review_aroma = mean(review_aroma, na.rm = TRUE)) %>% 
  ggplot(aes(x = mean_review_overall, y = mean_review_aroma)) + 
  geom_point() + 
  geom_smooth()
```

I'm curious what type of 

```{r}
df %>% 
  select(beer_beerid, review_overall, review_aroma, review_taste) %>% 
  mutate(
    review_class = case_when(
      review_overall < 1 ~ "A", 
      review_overall < 2 ~ "B", 
      review_overall < 3 ~ "C", 
      review_overall < 4 ~ "D", 
      TRUE ~ "E")) %>% 
  group_by(beer_beerid) %>% 
  summarise(mean_review_aroma = mean(review_aroma, na.rm = TRUE)) %>% 
  ggplot(aes(x = review_class, y = mean_review_aroma)) %>% 
  geom_boxplot()
```

## R Session Info

```{r r-session-info}
pander::pander(sessionInfo())
```
